class ProteinsController < ApplicationController

  hobo_model_controller
  
  caches_page :show
  
  autocomplete :name, :query_scope => [:name_contains, :ac_contains]
  auto_actions :all
  show_actions :filter

  
  
  def index
  	
    @documentations = Documentation.all.group_by(&:name)
    @perpage = 10
  	quick = 0
  	
  	joins = Array.new
  	includes = Array.new
    conditions = Array.new
    andconditions = Array.new
    andqueries = Array.new
    orconditions = Array.new
    orqueries = Array.new
    orlikeconditions = Array.new
    orlikequeries = Array.new
  	
  	#check if we want a fuzzy search
  	fuzzy = false
  	fuzzy = params[:query].match(/\*$/).present? if params[:query].present?
  	fuzzy = true if params.has_key?(:fuzzy)
  	
  	#check if the query would match a merops id
  	# merops = params[:query].match(/((\A[A-Za-z]{1}\d{2}\.{1}\d{3}\z)|(\A[A-Za-z]{1}\d{2}\z)|(^[A-Za-z]{1}\d{2}[A-Za-z]{1}$)|(^[A-Za-z]{1}\d{1}[A-Za-z]{1}$))/) if params[:query].present?
    # params[:query].gsub!(/((^[A-Za-z]{1}\d{2}\.{1}\d{3}$)|(^[A-Za-z]{1}\d{2}$)|(^[A-Za-z]{1}\d{2}[A-Za-z]{1}$)|(^[A-Za-z]{1}\d{1}[A-Za-z]{1}$))/,'') if merops.present?
  	# y merops[0]
  	# y merops[1]
  	# y merops[2]
  	# y merops[3]
  	# meropscode = merops[2] if merops.present?
    # meropsfamily = merops[1] if merops.present?
    # meropssubfamily = merops[3] if merops.present?
    # meropsclan = merops[4] if merops.present?
  	
  	#take the shortcut when searching for a single existing accession
  	if params[:query].present?
  	  # if it matches the accession number schema
  	  match = params[:query].match(/^[A-Za-z]\w{4,6}$/).present?
  	  protein = Protein.find_by_ac(params[:query]) if match
  	end
    if protein.present?
     redirect_to protein
    
    # else do normal search
    elsif (params.keys&['query','species','function','modification','chromosome']).present?

      #extract species
      if params[:query].present?
  
     
        match = params[:query].match(/(human|mouse|arabidopsis|yeast|ecoli)/)
        if match
           params[:query].gsub!(/((\A|\s)(human|mouse|arabidopsis|yeast|ecoli|)(\z|\s))/,'')
           case match[1]
             when 'human'
               params[:species] = 'Homo sapiens'
             when 'mouse'
               params[:species] = 'Mus musculus'
             when 'arabidopsis'
               params[:species] = 'Arabidopsis thaliana'
             when 'yeast'
               params[:species] = 'Saccharomyces cerevisiae'
             when 'ecoli'
               params[:species] = 'Esherichia coli'
           end
         end  
      end 
      genename = params[:query].match(/^([a-zA-Z]+)(\s|-|_|)(\d+)$/)
      variations = ['','-','_']
      namevariants = variations.map { |c| "#{genename[1]}#{c}#{genename[3]}"}.join("','") if genename.present? 
  		
      #we always join in those tables when we have a query
      if params[:query].present?
        # joins << :acs
        joins << :proteinnames
      end
      
      #species  
        if params[:species].present?   
          andconditions << "species.name = '#{params[:species]}'" 
          joins <<  :species 
        end
      #//species   
      
      #modification
        if params[:modification].present?
          andconditions << "(terminusmodifications_cterms.name = '#{params[:modification]}' OR terminusmodifications.name = '#{params[:modification]}')"

          joins <<  {:nterms => {:terminusmodification => :kw} }
          joins <<  {:cterms => {:terminusmodification => :kw} }
        end
      #//modification       
 
      #chromosome
        if params[:chromosome].present?
          andconditions << "proteins.chromosome = '#{params[:chromosome]}'"
          if params[:arm].present? 
            if params[:band].present?
              andconditions << "proteins.band LIKE ?"
              andqueries << "#{params[:arm]}#{params[:band]}%"
            else
              andconditions << "proteins.band LIKE ?"
              andqueries << "#{params[:arm]}%"
            end
          end
        end 
      #//chromosome      
  
      #function
        if params[:function].present?
          if params[:function] == 'protease'
            joins << :substrates
          elsif params[:function] =='inhibitor'
            joins << :inhibited_proteases
          end
        end
      #//function    
      
      #merops
        if params[:query].present?
          # codes = Array.new
          # codes << [meropscode] if meropscode.present?
          # codes << Merops.family_is(meropsfamily).*.code if meropsfamily.present?
          # codes << Merops.subfamily_is(meropssubfamily).*.code  if meropssubfamily.present?
          # codes << Merops.clan_is(meropsclan).*.code  if meropsclan.present?
          codes = Merops.all(:conditions => ["family = ? OR subfamily = ? OR code = ?",params[:query],params[:query],params[:query]],:select=> :code).*.code
          meropscodes = codes.flatten.compact.uniq.join("','")
          meropsquery = ""
          meropsquery = params[:query] if meropscodes.present?
          
          joins << :drs
          orconditions << "drs.protein_name IN ('#{meropscodes}')"
          @meropslimited = true
        end
      #//merops
  
      #search for exact matches if we have a query
      if params[:query].present?
        if namevariants.present?
          orconditions << "proteins.name IN ('#{namevariants}')"
          orconditions << "full IN ('#{namevariants}')"
          orconditions << "short IN ('#{namevariants}')"          
        else 
          orconditions << "proteins.name = '#{params[:query]}'"
          orconditions << "proteins.ac = '#{params[:query]}'"
          # orconditions << "acs.name LIKE '#{params[:query]}'"
          orconditions << "proteinnames.full = '#{params[:query]}'"
          orconditions << "proteinnames.short = '#{params[:query]}'"
        end
      end

      #search for partial matches if we have a query
      if params[:query].present? && !fuzzy
        orlikeconditions << "proteins.name LIKE ?"
        orlikequeries << "%#{params[:query]}%"
        orlikeconditions << "proteins.ac LIKE ?"
        orlikequeries << "%#{params[:query]}%"
        # orconditions << "acs.name LIKE '#{params[:query]}'"
        # orlikequeries << "%#{params[:query]}%"
        orlikeconditions << "proteinnames.full LIKE ?"
        orlikequeries << "%#{params[:query]}%"
        orlikeconditions << "proteinnames.short LIKE ?"
        orlikequeries << "%#{params[:query]}%"
      end      
      

      
      querystring = Array.new
      querystring << andconditions if andconditions.present?
      querystring << "(#{orconditions.join(' OR ')})" if orconditions.present?
      querystring.compact!
      conditions << querystring.join(' AND ')
      conditions << andqueries
      conditions << orqueries
      conditions = conditions.flatten.compact
      
      rescount = 0
      res = Protein.all :joins => joins, :conditions => conditions, :group => 'proteins.ac' unless fuzzy
      rescount = res.count unless fuzzy
      if rescount == 0
        conditions = Array.new
        querystring = Array.new
        querystring << andconditions  if andconditions.present?
        querystring  << "(#{orlikeconditions.join(' OR ')})" if orlikeconditions.present?
        querystring.compact!
        conditions << querystring.join(' AND ')
        conditions << andqueries
        conditions << orlikequeries
        conditions = conditions.flatten.compact    
      elsif rescount == 1
        redirect_to res.first
      end  
    end
    y conditions
    hobo_index(protein,:joins => joins, :include => [{:nterms => {:terminusmodification => :kw}},{:cterms => {:terminusmodification => :kw}},:species, :proteinnames, :substrates, :proteases, :inhibitors, :inhibited_proteases  ], :conditions => conditions, :group => 'proteins.ac', :order => 'proteins.name' )
  end  		
		# ## by name or ac or other ids
		# if params[:query].present?
		  # # y params	  
			      # #check for variants of MMP10 / MMP-10 / MMP 10
      # ids = []
      # if ids.empty? 
        # match = params[:query].match(/([a-zA-Z]+)(\s|-|_|)(\d+)/)
# 
        # if match  
          # ids = []      
          # ids += Protein.name_or_ac_is("#{match[1]} #{match[3]}").*.id if match[2] != ' '
          # ids += Protein.name_or_ac_is("#{match[1]}-#{match[3]}").*.id if match[2] != '-'  
          # ids += Protein.name_or_ac_is("#{match[1]}_#{match[3]}").*.id if match[2] != '_'
          # ids += Protein.name_or_ac_is("#{match[1]}#{match[3]}").*.id if match[2] != ''
#           
          # ids += Protein.proteinnames_full_or_proteinnames_short_is("#{match[1]} #{match[3]}").*.id if match[2] != ' '
          # ids += Protein.proteinnames_full_or_proteinnames_short_is("#{match[1]}-#{match[3]}").*.id if match[2] != '-'  
          # ids += Protein.proteinnames_full_or_proteinnames_short_is("#{match[1]}_#{match[3]}").*.id if match[2] != '_'
          # ids += Protein.proteinnames_full_or_proteinnames_short_is("#{match[1]}#{match[3]}").*.id if match[2] != ''
# 
          # ids += Protein.drs_protein_name_is("#{match[1]} #{match[3]}").*.id if match[2] != ' '
          # ids += Protein.drs_protein_name_is("#{match[1]}-#{match[3]}").*.id if match[2] != '-'  
          # ids += Protein.drs_protein_name_is("#{match[1]}_#{match[3]}").*.id if match[2] != '_'
          # ids += Protein.drs_protein_name_is("#{match[1]}#{match[3]}").*.id if match[2] != ''
        # else  
          # ids = []  
          # ids += Protein.name_or_ac_is(params[:query]).*.id 
          # ids += Protein.proteinnames_full_or_proteinnames_short_is(params[:query]).*.id          
          # ids += Protein.drs_protein_name_is(params[:query]).*.id
        # end
        # ids.uniq!
      # end
# 			
			# #check merops	
			# if ids.empty?
	        	# codes = Merops.code_is(params[:query]).*.code
	        	# codes = Merops.family_is(params[:query]).*.code if codes.empty?
	    		# codes = Merops.subfamily_is(params[:query]).*.code if codes.empty?
	    		# unless codes.empty?
	    			# @meropsquery = params[:query]
	    			# ids = Protein.drs_protein_name_in(codes).*.id  
	    			# @meropssubstrates = Protein.id_in(ids).*.substrates.flatten if ids.present? && @meropsquery.present?	
	    		# else
	    			# ids = []  
	    		# end
	    # end
	    # ids = Protein.name_or_proteinnames_full_or_proteinnames_short_begins_with(params[:query]).*.id if ids.empty? 

  
  
  def show
    
    #convert request into :id, :isoform, chain
    @iso = nil
    @chain = nil
    if params[:id].include?('-')
      id = params[:id].split('-').first
      # @iso = Isoform.ac_is(params[:id]).first     
    else
      id = params[:id]
      # @chain = Chain.name_is(params[:chain]).first  
    end
    
    if params.key?(:chain)      
      # @chain = Chain.name_is(params[:chain]).first 
    end
     
   
    # hobo_show @protein = Protein.id_or_ac_or_name_is(id).first  
    hobo_show @protein = Protein.find_by_ac(id)  
     
    @annotations_main = @protein.ccs.main
    @annotations_additional = @protein.ccs.additional
    @documentations = Documentation.all.group_by(&:name)


    
    @cleavages = Cleavage.apply_scopes(
      :protease_is => @protein)
    @cleavages = @cleavages.map {|x| x if x.substrate_id}.compact
    
    @cleavagesites = Cleavage.apply_scopes(
      :protease_is => @protein).*.cleavagesite
    @cleavagesites.delete(nil)
    
    @inverse_cleavages = Cleavage.apply_scopes(
      :substrate_is => @protein)
      
    @inhibitions = Inhibition.apply_scopes(
      :inhibitor_is => @protein
      )

    @inverse_inhibitions = Inhibition.apply_scopes(
      :inhibited_protease_is => @protein
      )      
      
    @cterms = Cterm.apply_scopes(
      :protein_is => @protein
      )
      
    @nterms = Nterm.apply_scopes(
      :protein_is => @protein
      )      
    
    analysis = Analysis.new(@protein,
                @cleavages,
                @cleavagesites,
                @inverse_cleavages,
                @inhibitions,
                @inverse_inhibitions,
                @cterms,
                @nterms,
                false)
    @network = analysis.graph
    @simplepanel = analysis.simplepanel
    if @protein.isprotease && !@cleavagesites.nil?
      @icelogopath = analysis.icelogo      
      @heatmap = Heatmap.new(@cleavagesites)
    end
    
    
    @params = params
    evidences = @protein.inverse_cleavages.*.evidences << @protein.cleavages.*.evidences << @protein.inhibitions.*.evidences << @protein.inverse_inhibitions.*.evidences << @protein.nterms.*.evidences << @protein.cterms.*.evidences
    evidences = evidences.flatten.uniq
    @filter_directness = evidences.*.directness.flatten.uniq
    @filter_physrel = evidences.*.phys_relevance.flatten.uniq
    @filter_evidencecodes = evidences.*.evidencecodes.flatten.uniq.*.name.uniq
    @filter_confidence_type = evidences.*.confidence_type.flatten.uniq
    @filter_tissues = evidences.*.tissues.flatten.uniq.*.name.uniq
    @filter_sources = evidences.*.evidencesource.flatten.compact.uniq.*.dbname.uniq
    labs = evidences.*.lab
    labs.present? ? @filter_labs = labs.flatten.uniq.compact.sort : @filtere_labs = labs
    @filter_evidences = evidences.*.name.uniq
    @filter_gocomponents = evidences.*.gocomponents.flatten.uniq.*.name.uniq
    @filter_methods = evidences.*.method.uniq
     
  end


  def filter
    @params = params
    #remove isofrom from ac
    id = params[:id].split('-').first
    hobo_show @protein = Protein.id_or_ac_or_name_is(id).first  
    ids = nil
    
    #filter:
    if params[:phys_rel].present?
    	paramids = Evidence.phys_relevance_in(params[:phys_rel]).*.id 
    	ids.present? ? ids = ids & paramids : ids = paramids
    end
    if params[:directness].present?
  		paramids = Evidence.directness_in(params[:directness]).*.id
    	ids.present? ? ids = ids & paramids : ids = paramids
    end
    if params[:confidence].present? && params[:confidence_type].present?
      paramids = Evidence.confidence_gte(params[:confidence]).*.id
      paramids2 = Evidence.confidence_type_in(params[:confidence_type]).*.id
      ids.present? ? ids = ids & paramids & paramids2 : ids = paramids & paramids2
    end
    if params[:tissues].present?
  		paramids = Evidence.tissues_tsid_in(params[:tissues]).*.id
    	ids.present? ? ids = ids & paramids : ids = paramids
    end
    if params[:evidencecodes].present?
  		paramids = Evidence.evidencecodes_name_in(params[:evidencecodes]).*.id
    	ids.present? ? ids = ids & paramids : ids = paramids
    end
    if params[:methods].present?
  		paramids = Evidence.method_in(params[:methods]).*.id
    	ids.present? ? ids = ids & paramids : ids = paramids
    end
    if params[:sources].present?
  		paramids = Evidence.evidencesource_dbname_in(params[:sources]).*.id
    	ids.present? ? ids = ids & paramids : ids = paramids
    end
    if params[:labs].present?
  		paramids = Evidence.lab_in(params[:labs]).*.id
    	ids.present? ? ids = ids & paramids : ids = paramids
    end
    if params[:evidences].present?
  		paramids = Evidence.name_in(params[:evidences]).*.id
    	ids.present? ? ids = ids & paramids : ids = paramids
    end
    
    ids.blank? ?  filteredevidences = nil : filteredevidences = ids.uniq

 
    @annotations_main = @protein.ccs.main
    @annotations_additional = @protein.ccs.additional
    @documentations = Documentation.all.group_by(&:name)

    @allcleavages = Cleavage.apply_scopes(
      :protease_is => @protein)
	@allcleavages = @allcleavages.map {|x| x if (filteredevidences & x.evidences.*.id).present?}.compact      
    @cleavagesites = @allcleavages.*.cleavagesite.compact
    
    
    @cleavages = @allcleavages.map {|x| x if x.substrate_id}.compact
    
    @inverse_cleavages = Cleavage.apply_scopes(
      :substrate_is => @protein).map {|x| x if (filteredevidences & x.evidences.*.id).present?}.compact
      
    @inhibitions = Inhibition.apply_scopes(
      :inhibitor_is => @protein
      ).map {|x| x if (filteredevidences & x.evidences.*.id).present?}.compact

    @inverse_inhibitions = Inhibition.apply_scopes(
      :inhibited_protease_is => @protein
      ).map {|x| x if (filteredevidences & x.evidences.*.id).present?}.compact    
      
    @cterms = Cterm.apply_scopes(
      :protein_is => @protein
      ).map {|x| x if (filteredevidences & x.evidences.*.id).present?}.compact    
      
    @nterms = Nterm.apply_scopes(
      :protein_is => @protein
    ).map {|x| x if (filteredevidences & x.evidences.*.id).present?}.compact         

      
    analysis = Analysis.new(@protein,
                @cleavages,
                @cleavagesites,
                @inverse_cleavages,
                @inhibitions,
                @inverse_inhibitions,
                @cterms,
                @nterms,
                true,
                filteredevidences)
    @network = analysis.graph
    @simplepanel = analysis.simplepanel

    if @protein.isprotease && !@cleavagesites.nil? && !@cleavagesites.empty?
      @icelogopath = analysis.icelogo('_filtered')      
      @heatmap = Heatmap.new(@cleavagesites)
    end
            
    
    evidences = @protein.inverse_cleavages.*.evidences << @protein.cleavages.*.evidences << @protein.inhibitions.*.evidences << @protein.inverse_inhibitions.*.evidences << @protein.nterms.*.evidences << @protein.cterms.*.evidences
    evidences = evidences.flatten.uniq
    @filter_directness = evidences.*.directness.flatten.uniq
    @filter_physrel = evidences.*.phys_relevance.flatten.uniq
    @filter_confidence_type = evidences.*.confidence_type.flatten.uniq
    @filter_evidencecodes = evidences.*.evidencecodes.flatten.uniq.*.name.sort
    @filter_tissues = evidences.*.tissues.flatten.uniq.*.name.sort
    @filter_evidencecodes = evidences.*.evidencecodes.flatten.uniq.*.name.sort
    @filter_tissues = evidences.*.tissues.flatten.uniq.*.name.sort
    @filter_sources = evidences.*.evidencesource.flatten.compact.uniq.*.dbname.sort
    labs = evidences.*.lab
    labs.present? ? @filter_labs = labs.flatten.uniq.compact.sort : @filtere_labs = labs
    @filter_evidences = evidences.*.name.sort
    @filter_gocomponents = evidences.*.gocomponents.flatten.uniq.*.name.sort
    @filter_methods = evidences.*.method.uniq.sort
    
    
  end 
  
 
  def apiget
    @params = params
    #remove isofrom from ac
    id = params[:id].split('-').first
    @protein = Protein.id_or_ac_or_name_is(id).first  
    ids = nil
    
    @getfeatures = params.has_key?('get_xcorr_features')
    @getevidences = params.has_key?('get_evidences')
    
    #filter:
    if params[:phys_rel].present?
      filter = true
      paramids = Evidence.phys_relevance_in(params[:phys_rel]).*.id 
      ids.present? ? ids = ids & paramids : ids = paramids
    end
    if params[:directness].present?
      filter = true
      paramids = Evidence.directness_in(params[:directness]).*.id
      ids.present? ? ids = ids & paramids : ids = paramids
    end
    if params[:tissues].present?
      filter = true
      paramids = Evidence.tissues_ac_in(params[:tissues]).*.id
      ids.present? ? ids = ids & paramids : ids = paramids
    end
    if params[:evidencecodes].present?
      filter = true
      paramids = Evidence.evidencecodes_name_in(params[:evidencecodes]).*.id
      ids.present? ? ids = ids & paramids : ids = paramids
    end
    # if params[:methods].present?
      # paramids = Evidence.method_like(params[:methods]).*.id
      # ids.present? ? ids = ids & paramids : ids = paramids
    # end
    # if params[:sources].present?
      # paramids = Evidence.evidencesource_dbname_in(params[:sources]).*.id
      # ids.present? ? ids = ids & paramids : ids = paramids
    # end
    if params[:labs].present?
      filter = true
      paramids = Evidence.lab_in(params[:labs]).*.id
      ids.present? ? ids = ids & paramids : ids = paramids
    end
    if params[:evidences].present?
      filter = true
      paramids = Evidence.name_in(params[:evidences]).*.id
      ids.present? ? ids = ids & paramids : ids = paramids
    end
    
    ids.blank? ?  filteredevidences = nil : filteredevidences = ids.uniq

 
    @annotations_main = @protein.ccs.main
    @annotations_additional = @protein.ccs.additional
    @documentations = Documentation.all.group_by(&:name)

    unless filter
      @cleavages = Cleavage.apply_scopes(
        :protease_is => @protein)
      @cleavages = @cleavages.map {|x| x if x.substrate_id}.compact
      
      @cleavagesites = Cleavage.apply_scopes(
        :protease_is => @protein).*.cleavagesite
      @cleavagesites.delete(nil)
      
      @inverse_cleavages = Cleavage.apply_scopes(
        :substrate_is => @protein)
        
      @inhibitions = Inhibition.apply_scopes(
        :inhibitor_is => @protein
        )
  
      @inverse_inhibitions = Inhibition.apply_scopes(
        :inhibited_protease_is => @protein
        )      
        
      @cterms = Cterm.apply_scopes(
        :protein_is => @protein
        )
        
      @nterms = Nterm.apply_scopes(
        :protein_is => @protein
        )      
    else 
      #filtered
      @allcleavages = Cleavage.apply_scopes(
        :protease_is => @protein)
      @allcleavages = @allcleavages.map {|x| x if (filteredevidences & x.evidences.*.id).present?}.compact      
      @cleavagesites = @allcleavages.*.cleavagesite.compact
      
      
      @cleavages = @allcleavages.map {|x| x if x.substrate_id}.compact
      
      @inverse_cleavages = Cleavage.apply_scopes(
        :substrate_is => @protein).map {|x| x if (filteredevidences & x.evidences.*.id).present?}.compact
        
      @inhibitions = Inhibition.apply_scopes(
        :inhibitor_is => @protein
        ).map {|x| x if (filteredevidences & x.evidences.*.id).present?}.compact
  
      @inverse_inhibitions = Inhibition.apply_scopes(
        :inhibited_protease_is => @protein
        ).map {|x| x if (filteredevidences & x.evidences.*.id).present?}.compact    
        
      @cterms = Cterm.apply_scopes(
        :protein_is => @protein
        ).map {|x| x if (filteredevidences & x.evidences.*.id).present?}.compact    
        
      @nterms = Nterm.apply_scopes(
        :protein_is => @protein
      ).map {|x| x if (filteredevidences & x.evidences.*.id).present?}.compact         
  
    end #filtered              
    
    evidences = @protein.inverse_cleavages.*.evidences << @protein.cleavages.*.evidences << @protein.inhibitions.*.evidences << @protein.inverse_inhibitions.*.evidences << @protein.nterms.*.evidences << @protein.cterms.*.evidences
    evidences = evidences.flatten.uniq
    
    respond_to do |format|
      format.xml
    end    
    
  end 
  
  def apisearch
    @perpage = 50
    count = params.has_key?('count')
    spec = params[:species]
      
      joins = Array.new
      joins << :species if params[:species].present?
      joins << :nterms if (params[:ntermini_at].present? || params[:ntermini_before].present? || params[:ntermini_after].present?)
      # joins << {:nterms => [:evidences]} if ((params[:directness].present? || params[:relevance].present? || params[:confidence_greater].present?) && (params[:ntermini_at].present? || params[:ntermini_before].present? || params[:ntermini_after].present?))
            
      joins << :cterms if (params[:ctermini_at].present? || params[:ctermini_before].present? || params[:ctermini_after].present?)
      # joins << {:cterms => [:evidences]} if ((params[:directness].present? || params[:relevance].present? || params[:confidence_greater].present?) && (params[:ctermini_at].present? || params[:ctermini_before].present? || params[:ctermini_after].present?))
      
      joins << :cleavages if (params[:cleavages_at].present? || params[:cleavages_before].present? || params[:cleavages_after].present?)
      # joins << {:cleavages => [:evidences]} if ((params[:directness].present? || params[:relevance].present? || params[:confidence_greater].present?) && (params[:cleavages_at].present? || params[:cleavages_before].present? || params[:cleavages_after].present? || params[:cleaved_by].present? || params[:cleaves].present?))

      joins << :inhibitions if (params[:inhibits].present? || params[:inhibited_by].present?)
      joins << :proteases if params[:cleaved_by].present?
      joins << :substrates if params[:cleaves].present?
      joins << :inhibitors if params[:inhibits].present?
      joins << :inhibited_proteases if params[:inhibited_by].present?
    
      
      conditions = Array.new
      conditions << "species.name = '#{params[:species]}'" if params[:species].present?
      conditions << "proteases_proteins.ac IN ('#{params[:cleaved_by]}')" if params[:cleaved_by].present?
      conditions << "substrates_proteins.ac IN ('#{params[:cleaves]}')" if params[:cleaves].present?      
      conditions << "inhibitors_proteins.ac IN ('#{params[:inhibits]}')" if params[:inhibits].present?      
      conditions << "inhibited_proteases_proteins.ac IN ('#{params[:inhibited_by]}')" if params[:inhibited_by].present?
      conditions << "cleavages.pos = '#{params[:cleavages_at]}'" if params[:cleavages_at].present?
      conditions << "cleavages.pos < '#{params[:cleavages_before]}'" if params[:cleavages_before].present?
      conditions << "cleavages.pos > '#{params[:cleavages_after]}'" if params[:cleavages_after].present?
      conditions << "nterms.pos = '#{params[:ntermini_at]}'" if params[:ntermini_at].present?
      conditions << "nterms.pos < '#{params[:ntermini_before]}'" if params[:ntermini_before].present?
      conditions << "nterms.pos > '#{params[:ntermini_after]}'" if params[:ntermini_after].present?
      conditions << "cterms.pos = '#{params[:ctermini_at]}'" if params[:ctermini_at].present?
      conditions << "cterms.pos < '#{params[:ctermini_before]}'" if params[:ctermini_before].present?
      conditions << "cterms.pos > '#{params[:ctermini_after]}'" if params[:ctermini_after].present?
      # conditions << "evidences.directness = '#{params[:directness]}'" if params[:directness].present?
      # conditions << "evidences.phys_relevance = '#{params[:relevance]}'" if params[:relevance].present?
      # conditions << "evidences.confidence >= '#{params[:confidence_greater]}'" if params[:confidence_greater].present?
      
      @proteins = Protein.all :joins => joins, :conditions => conditions.join(' AND ').to_a, :group => 'proteins.ac'   
      
      if count
        @count = @proteins.count
        @pages = (@count/@perpage).ceil
      end
    
      @proteins = @proteins.paginate :page => params[:page], :per_page => @perpage
     
    respond_to do |format|
      format.xml
    end    
  end

    

end
